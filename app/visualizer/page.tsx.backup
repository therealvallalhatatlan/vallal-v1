// app/visualizer/page.tsx
"use client";

import { Suspense, useEffect, useRef, useState, useCallback } from "react";
import { useSearchParams } from "next/navigation";
import { GIFEncoder, quantize, applyPalette } from "gifenc";

type BlendMode =
  | "source-over"
  | "lighter"
  | "screen"
  | "multiply"
  | "overlay"
  | "darken"
  | "lighten"
  | "difference";

function lerp(a: number, b: number, t: number) {
  return a + (b - a) * t;
}

export default function VisualizerPage() {
  return (
    <Suspense fallback={<div className="flex h-screen items-center justify-center text-white">Loading‚Ä¶</div>}>
      <VisualizerContent />
    </Suspense>
  );
}

function VisualizerContent() {
  const search = useSearchParams();
  const q1 = search?.get("img1");
  const q2 = search?.get("img2");

  const defaultA = "/img/visuals/noise-54.jpg";
  const defaultB = "/img/visuals/noise-2025.png";

  const [imageA, setImageA] = useState(q1 || defaultA);
  const [imageB, setImageB] = useState(q2 || defaultB);
  const [showImagePicker, setShowImagePicker] = useState<"A" | "B" | null>(null);
  const [imageInputValue, setImageInputValue] = useState("");
  const [showControls, setShowControls] = useState(true);
  const hideControlsTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [activeTab, setActiveTab] = useState<"effects" | "images" | "export">("effects");
  const [dragOver, setDragOver] = useState<"A" | "B" | null>(null);

  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const ctxRef = useRef<CanvasRenderingContext2D | null>(null);
  const rafRef = useRef<number | null>(null);

  const [loadedImgs, setLoadedImgs] = useState<HTMLImageElement[]>([]);
  const [playing, setPlaying] = useState(true);
  const [exporting, setExporting] = useState<null | "gif" | "webm">(null);

  // --- USER TARGET CONTROLS (what UI sets) ---
  const [targetGlitch, setTargetGlitch] = useState(0.6); // 0..1 (tamed)
  const [targetGrain, setTargetGrain] = useState(0.08); // 0..0.25
  const [targetSlices, setTargetSlices] = useState(8); // 2..24
  const [targetRgbShift, setTargetRgbShift] = useState(1); // 0..0.12
  const [targetVignette, setTargetVignette] = useState(0.12); // 0..0.3
  const [targetScaleOffset, setTargetScaleOffset] = useState(0.01); // -0.06..0.06
  const [targetRotationDeg, setTargetRotationDeg] = useState(1); // -6..6
  const [targetSaturation, setTargetSaturation] = useState(1); // 0..2.5 (1 = default)
  const [blendMode, setBlendMode] = useState<BlendMode>("difference");
  const [noiseOverlay, setNoiseOverlay] = useState(true);
  const [tintHue, setTintHue] = useState(0); // degrees
  const [speed, setSpeed] = useState(1.0);
  const [seed, setSeed] = useState(() => Math.floor(Math.random() * 99999));
  const [autoshift, setAutoshift] = useState(true);

  // Preset configurations
  const presets = {
    glitchHeavy: {
      name: "Glitch Heavy",
      glitch: 0.8,
      grain: 0.15,
      slices: 16,
      rgbShift: 0.08,
      vignette: 0.2,
      scaleOffset: 0.04,
      rotation: 3,
      saturation: 1.2,
      blendMode: "difference" as BlendMode,
    },
    subtle: {
      name: "Subtle",
      glitch: 0.2,
      grain: 0.03,
      slices: 4,
      rgbShift: 0.01,
      vignette: 0.05,
      scaleOffset: 0.005,
      rotation: 0,
      saturation: 1.0,
      blendMode: "overlay" as BlendMode,
    },
    cyberpunk: {
      name: "Cyberpunk",
      glitch: 0.7,
      grain: 0.12,
      slices: 12,
      rgbShift: 0.06,
      vignette: 0.25,
      scaleOffset: 0.02,
      rotation: 2,
      saturation: 1.8,
      blendMode: "screen" as BlendMode,
    },
    retro: {
      name: "Retro VHS",
      glitch: 0.5,
      grain: 0.2,
      slices: 8,
      rgbShift: 0.04,
      vignette: 0.15,
      scaleOffset: 0.01,
      rotation: 1,
      saturation: 0.8,
      blendMode: "multiply" as BlendMode,
    },
  };

  const applyPreset = useCallback((presetKey: keyof typeof presets) => {
    const preset = presets[presetKey];
    setTargetGlitch(preset.glitch);
    setTargetGrain(preset.grain);
    setTargetSlices(preset.slices);
    setTargetRgbShift(preset.rgbShift);
    setTargetVignette(preset.vignette);
    setTargetScaleOffset(preset.scaleOffset);
    setTargetRotationDeg(preset.rotation);
    setTargetSaturation(preset.saturation);
    setBlendMode(preset.blendMode);
  }, []);

  // --- SMOOTHED RUNTIME VALUES (interpolated each frame) ---
  const cur = useRef({
    glitch: targetGlitch,
    grain: targetGrain,
    slices: targetSlices,
    rgbShift: targetRgbShift,
    vignette: targetVignette,
    scaleOffset: targetScaleOffset,
    rotation: targetRotationDeg,
    speed,
    saturation: targetSaturation,
  });

  // Handle file upload
  const handleFileUpload = useCallback((file: File, target: "A" | "B") => {
    if (!file.type.startsWith("image/")) {
      alert("Please select a valid image file");
      return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
      const dataUrl = e.target?.result as string;
      if (target === "A") {
        setImageA(dataUrl);
      } else {
        setImageB(dataUrl);
      }
      setShowImagePicker(null);
    };
    reader.onerror = () => {
      alert("Error reading file");
    };
    reader.readAsDataURL(file);
  }, []);

  // Handle drag and drop
  const handleDragOver = useCallback((e: React.DragEvent, target: "A" | "B") => {
    e.preventDefault();
    e.stopPropagation();
    setDragOver(target);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragOver(null);
  }, []);

  const handleDrop = useCallback((e: React.DragEvent, target: "A" | "B") => {
    e.preventDefault();
    e.stopPropagation();
    setDragOver(null);

    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      handleFileUpload(files[0], target);
    }
  }, [handleFileUpload]);

  // Handle URL input
  const handleUrlInput = useCallback((url: string, target: "A" | "B") => {
    const trimmedUrl = url.trim();
    if (!trimmedUrl) {
      alert("Please enter a valid URL");
      return;
    }
    
    // Basic URL validation
    if (!trimmedUrl.startsWith("data:") && !trimmedUrl.startsWith("/") && !trimmedUrl.startsWith("http://") && !trimmedUrl.startsWith("https://")) {
      alert("Please enter a valid URL (starting with http://, https://, or /)");
      return;
    }
    
    if (target === "A") {
      setImageA(trimmedUrl);
    } else {
      setImageB(trimmedUrl);
    }
    setShowImagePicker(null);
    setImageInputValue("");
  }, []);

  // preload images (keep order)
  useEffect(() => {
    let cancelled = false;
    setLoadedImgs([]);
    const imgs: HTMLImageElement[] = [];
    [imageA, imageB].forEach((src, idx) => {
      const img = new Image();
      // Only set crossOrigin for external URLs, not for data URLs
      if (!src.startsWith("data:")) {
        img.crossOrigin = "anonymous";
      }
      (img as any).decoding = "async";
      img.referrerPolicy = "no-referrer";
      img.onload = () => {
        if (cancelled) return;
        imgs[idx] = img;
        // only set when both attempted to load so array order stable
        setLoadedImgs(() => imgs.filter(Boolean) as HTMLImageElement[]);
      };
      img.onerror = () => {
        if (cancelled) return;
        console.error(`Failed to load image ${idx === 0 ? "A" : "B"}: ${src.substring(0, 100)}`);
        
        // If it's an external URL and direct loading failed, try using proxy
        if (src.startsWith("http://") || src.startsWith("https://")) {
          console.log(`Attempting to load via proxy: ${src.substring(0, 100)}`);
          const proxyUrl = `/api/image-proxy?url=${encodeURIComponent(src)}`;
          if (img.src !== proxyUrl) {
            img.src = proxyUrl;
            return;
          }
        }
        
        // Final fallback to default images
        const fallback = idx === 0 ? defaultA : defaultB;
        if (src !== fallback && img.src !== fallback) {
          img.src = fallback;
        }
      };
      img.src = src;
    });

    return () => {
      cancelled = true;
    };
  }, [imageA, imageB, seed]);

  // canvas sizing
  useEffect(() => {
    const c = canvasRef.current;
    if (!c) return;
    const resize = () => {
      const rect = c.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.max(1, Math.floor(rect.width * dpr));
      const h = Math.max(1, Math.floor(rect.height * dpr));
      if (c.width !== w) c.width = w;
      if (c.height !== h) c.height = h;
      if (!ctxRef.current) ctxRef.current = c.getContext("2d");
    };
    resize();
    const ro = new ResizeObserver(resize);
    ro.observe(c);
    return () => ro.disconnect();
  }, []);

  // drawing loop (smoothed / less destructive)
  useEffect(() => {
    cancelAnim();
    if (!playing) return;
    const c = canvasRef.current;
    const ctx = ctxRef.current;
    if (!c || !ctx) return;

    // seeded pseudo-rand for stable-looking glitches
    let rndState = seed || 1;
    const rnd = () => {
      rndState = (rndState * 9301 + 49297) % 233280;
      return rndState / 233280;
    };

    const draw = () => {
      const W = c.width;
      const H = c.height;
      ctx.clearRect(0, 0, W, H);

      const t = Date.now() / 1000;
      // smooth parameters toward target (slow lerp)
      const smooth = 0.08;
      cur.current.glitch = lerp(cur.current.glitch, targetGlitch, smooth);
      cur.current.grain = lerp(cur.current.grain, targetGrain, smooth);
      cur.current.slices = Math.round(lerp(cur.current.slices, targetSlices, smooth));
      cur.current.rgbShift = lerp(cur.current.rgbShift, targetRgbShift, smooth);
      cur.current.vignette = lerp(cur.current.vignette, targetVignette, smooth);
      cur.current.scaleOffset = lerp(cur.current.scaleOffset, targetScaleOffset, smooth);
      cur.current.rotation = lerp(cur.current.rotation, targetRotationDeg, smooth);
      cur.current.speed = lerp(cur.current.speed, speed, smooth);
      cur.current.saturation = lerp(cur.current.saturation, targetSaturation, smooth);

      const glitch = Math.max(0, Math.min(1.0, cur.current.glitch));
      const grain = Math.max(0, Math.min(0.3, cur.current.grain));
      const slices = Math.max(2, Math.min(40, cur.current.slices));
      const rgbShift = Math.max(0, Math.min(0.14, cur.current.rgbShift));
      const vign = Math.max(0, Math.min(0.5, cur.current.vignette));
      const scaleOff = Math.max(-0.2, Math.min(0.2, cur.current.scaleOffset));
      const rot = Math.max(-12, Math.min(12, cur.current.rotation));
      const spd = Math.max(0.2, Math.min(2.0, cur.current.speed));
      const sat = Math.max(0, Math.min(2.5, cur.current.saturation));

      // gentle background tint
      if (tintHue !== 0) {
        ctx.fillStyle = `hsla(${tintHue}, 30%, 6%, 0.08)`;
        ctx.fillRect(0, 0, W, H);
      } else {
        // subtle paper texture base
        ctx.fillStyle = "#050505";
        ctx.fillRect(0, 0, W, H);
      }

      // draw two layers with subtle transforms
      loadedImgs.forEach((img, idx) => {
        if (!img || !img.complete) return;
        // cover scale but keep small differential between layers
        const coverScale =
          Math.max(W / img.naturalWidth, H / img.naturalHeight) *
          (1 + (idx === 0 ? scaleOff : -scaleOff) * 0.6);
        const sw = img.naturalWidth * coverScale;
        const sh = img.naturalHeight * coverScale;

        // controlled movement
        const phase = t * (0.12 + idx * 0.04) * spd;
        const ox = Math.sin(phase * (0.6 + idx * 0.2)) * 8 * glitch * (idx === 0 ? 1 : -1);
        const oy = Math.cos(phase * (0.8 + idx * 0.3)) * 8 * glitch * (idx === 0 ? -1 : 1);

        ctx.save();
        ctx.translate(W / 2 + ox, H / 2 + oy);
        // small rotation that is smoothed and gentle
        const rads = ((rot * Math.PI) / 180) * (idx === 0 ? 1 : -0.8);
        ctx.rotate(rads * (autoshift ? (Math.sin(t * 0.06 + idx) * 0.1 + 0.95) : 1));
        ctx.globalCompositeOperation = idx % 2 ? "lighter" : blendMode;
        ctx.filter = `saturate(${sat})`;
        try {
          ctx.drawImage(img, -sw / 2, -sh / 2, sw, sh);
        } catch (e) {
          // ignore draw errors
        }
        ctx.restore();
      });
      ctx.filter = "none";

      // softened sliced glitch: smaller offsets and less frequent
      const sliceFreq = Math.max(2, Math.floor(slices * (0.7 + glitch * 0.3)));
      for (let i = 0; i < sliceFreq; i++) {
        if (Math.random() > 0.9 - glitch * 0.15) continue;
        const y = Math.floor((H / sliceFreq) * i + (rnd() - 0.5) * 3);
        const h = Math.max(2, Math.floor(H / (sliceFreq * (1 + rnd() * 0.4))));
        const offset = (rnd() - 0.5) * 20 * glitch; // reduce maximum offset
        try {
          const id = ctx.getImageData(0, y, W, h);
          // soft put: use integer small offset and alpha blend to avoid harsh seams
          ctx.globalAlpha = 0.95;
          ctx.putImageData(id, Math.floor(offset), y);
          ctx.globalAlpha = 1;
        } catch {}
      }

      // occasional light RGB micro-shift but inexpensive: sample small region
      if (Math.random() < 0.06 * glitch) {
        try {
          // operate on a downsized temporary canvas to reduce cost
          const tw = Math.max(64, Math.floor(W / 4));
          const th = Math.max(64, Math.floor(H / 4));
          const tmp = document.createElement("canvas");
          tmp.width = tw;
          tmp.height = th;
          const tctx = tmp.getContext("2d");
          if (tctx) {
            tctx.drawImage(c, 0, 0, tw, th);
            const imgd = tctx.getImageData(0, 0, tw, th);
            const data = imgd.data;
            const copy = new Uint8ClampedArray(data);
            const sx = Math.max(-4, Math.min(4, Math.floor((rnd() - 0.5) * 8 * rgbShift)));
            const sy = Math.max(-2, Math.min(2, Math.floor((rnd() - 0.5) * 4 * rgbShift)));
            for (let y = 0; y < th; y++) {
              for (let x = 0; x < tw; x++) {
                const i = (y * tw + x) * 4;
                const jx = Math.max(0, Math.min(tw - 1, x + sx));
                const jy = Math.max(0, Math.min(th - 1, y + sy));
                const j = (jy * tw + jx) * 4;
                data[i] = copy[j]; // shift R channel only lightly
              }
            }
            tctx.putImageData(imgd, 0, 0);
            // upscale back with slight globalComposite to blend
            ctx.globalAlpha = 0.18 * rgbShift;
            ctx.drawImage(tmp, 0, 0, W, H);
            ctx.globalAlpha = 1;
          }
        } catch {}
      }

      // noise overlay (lighter, not heavy)
      if (noiseOverlay) {
        const alpha = 0.035 * grain;
        ctx.globalAlpha = alpha;
        const noiseCount = Math.floor(160 * grain);
        for (let i = 0; i < noiseCount; i++) {
          const x = Math.floor(rnd() * W);
          const y = Math.floor(rnd() * H);
          const s = Math.max(1, Math.floor(rnd() * 2));
          const g = Math.floor(rnd() * 255);
          ctx.fillStyle = `rgba(${g},${g},${g},${0.85 * alpha})`;
          ctx.fillRect(x, y, s, s);
        }
        ctx.globalAlpha = 1;
      }

      // subtle scanlines
      ctx.globalAlpha = 0.03 * grain;
      for (let y = 0; y < H; y += 3) {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, y, W, 1);
      }
      ctx.globalAlpha = 1;

      // vignette
      ctx.fillStyle = `rgba(0,0,0,${vign})`;
      ctx.beginPath();
      ctx.ellipse(W / 2, H / 2, W * 0.62, H * 0.62, 0, 0, Math.PI * 2);
      ctx.fill("evenodd");

      rafRef.current = requestAnimationFrame(draw);
    };

    const timer = setTimeout(() => (rafRef.current = requestAnimationFrame(draw)), 30);
    return () => {
      clearTimeout(timer);
      cancelAnim();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    loadedImgs,
    playing,
    targetGlitch,
    targetGrain,
    targetSlices,
    targetRgbShift,
    targetVignette,
    targetScaleOffset,
    targetRotationDeg,
    targetSaturation,
    blendMode,
    noiseOverlay,
    tintHue,
    speed,
    seed,
    autoshift,
  ]);

  function cancelAnim() {
    if (rafRef.current) cancelAnimationFrame(rafRef.current);
    rafRef.current = null;
  }

  function sleep(ms: number) {
    return new Promise<void>((resolve) => setTimeout(resolve, ms));
  }

  function nextFrame() {
    return new Promise<void>((resolve) => requestAnimationFrame(() => resolve()));
  }

  function getDownscaleDims(srcW: number, srcH: number, maxSize: number) {
    const maxDim = Math.max(1, Math.max(srcW, srcH));
    const scale = Math.min(1, maxSize / maxDim);
    const w = Math.max(1, Math.round(srcW * scale));
    const h = Math.max(1, Math.round(srcH * scale));
    return { w, h };
  }

  function downloadBlob(blob: Blob, filename: string) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // screenshot -> download canvas png
  const handleScreenshot = useCallback(() => {
    const c = canvasRef.current;
    if (!c) return;
    try {
      const data = c.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = data;
      a.download = `visualizer-${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (e) {
      console.error("Screenshot failed", e);
    }
  }, []);

  const handleExportGif = useCallback(async () => {
    if (exporting) return;
    const srcCanvas = canvasRef.current;
    if (!srcCanvas) return;

    const frames = 8;
    const fps = 10;
    const maxSize = 512;
    const delay = Math.round(1000 / fps);
    const captureIntervalMs = delay;
    const maxColors = 64;
    const format: "rgb444" = "rgb444";

    setExporting("gif");
    try {
      const { w, h } = getDownscaleDims(srcCanvas.width, srcCanvas.height, maxSize);

      const tmp = document.createElement("canvas");
      tmp.width = w;
      tmp.height = h;
      const tctx = tmp.getContext("2d", { willReadFrequently: true }) as CanvasRenderingContext2D;
      if (!tctx) throw new Error("No 2D context for GIF export");

      const gif = GIFEncoder();
      let palette: any = null;

      for (let i = 0; i < frames; i++) {
        await nextFrame();
        tctx.clearRect(0, 0, w, h);
        tctx.drawImage(srcCanvas, 0, 0, w, h);

        const imgData = tctx.getImageData(0, 0, w, h);
        const rgba = imgData.data;

        if (i === 0) {
          palette = quantize(rgba, maxColors, { format });
        }
        const index = applyPalette(rgba, palette, format);

        gif.writeFrame(index, w, h, {
          delay,
          dispose: 2,
          ...(i === 0 ? { palette, repeat: 0 } : {}),
        });

        if (i < frames - 1) await sleep(captureIntervalMs);
      }

      gif.finish();
      const bytes = gif.bytes();
      const blob = new Blob([bytes], { type: "image/gif" });
      downloadBlob(blob, `visualizer-${Date.now()}.gif`);
    } catch (e) {
      console.error("GIF export failed", e);
      alert("GIF export failed. Check console for details.");
    } finally {
      setExporting(null);
    }
  }, [exporting]);

  const handleRecordWebm = useCallback(async () => {
    if (exporting) return;
    const srcCanvas = canvasRef.current;
    if (!srcCanvas) return;
    if (typeof MediaRecorder === "undefined") {
      alert("WebM recording is not supported in this browser.");
      return;
    }

    const fps = 12;
    const maxSize = 720;
    const frames = 10;
    const durationMs = Math.max(200, Math.round((frames / fps) * 1000));

    setExporting("webm");
    try {
      const { w, h } = getDownscaleDims(srcCanvas.width, srcCanvas.height, maxSize);
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = w;
      exportCanvas.height = h;
      const ectx = exportCanvas.getContext("2d");
      if (!ectx) throw new Error("No 2D context for WebM export");

      let copying = true;
      const copyTick = () => {
        if (!copying) return;
        ectx.drawImage(srcCanvas, 0, 0, w, h);
        requestAnimationFrame(copyTick);
      };
      copyTick();

      const stream = exportCanvas.captureStream(fps);

      const preferredTypes = ["video/webm;codecs=vp9", "video/webm;codecs=vp8", "video/webm"];
      const mimeType = preferredTypes.find((t) => MediaRecorder.isTypeSupported(t)) || "";

      const videoBitsPerSecond = w >= 720 || h >= 720 ? 2_500_000 : 1_200_000;
      const recorder = new MediaRecorder(stream, {
        ...(mimeType ? { mimeType } : {}),
        videoBitsPerSecond,
      });

      const chunks: BlobPart[] = [];
      recorder.ondataavailable = (ev) => {
        if (ev.data && ev.data.size > 0) chunks.push(ev.data);
      };

      const stopped = new Promise<void>((resolve, reject) => {
        recorder.onstop = () => resolve();
        recorder.onerror = () => reject(new Error("MediaRecorder error"));
      });

      recorder.start();
      await sleep(durationMs);
      recorder.stop();
      await stopped;

      copying = false;
      stream.getTracks().forEach((t) => t.stop());

      const blob = new Blob(chunks, { type: recorder.mimeType || "video/webm" });
      downloadBlob(blob, `visualizer-${Date.now()}.webm`);
    } catch (e) {
      console.error("WebM record failed", e);
      alert("WebM export failed. Check console for details.");
    } finally {
      setExporting(null);
    }
  }, [exporting]);

  const handleRandomize = useCallback(() => {
    // set moderate randomized targets (not extreme)
    setSeed(Math.floor(Math.random() * 99999));
    setTargetGlitch(0.3 + Math.random() * 0.7);
    setTargetGrain(0.02 + Math.random() * 0.18);
    setTargetSlices(4 + Math.floor(Math.random() * 16));
    setTargetRgbShift(Math.random() * 0.09);
    setTargetVignette(0.03 + Math.random() * 0.22);
    setTargetRotationDeg(Math.floor(Math.random() * 8) - 4);
    setTargetScaleOffset((Math.random() - 0.5) * 0.06);
    setTargetSaturation(0.8 + Math.random() * 0.9);
    setTintHue(Math.floor(Math.random() * 40) - 20);
    setBlendMode((["difference", "overlay", "lighter", "screen", "multiply"] as BlendMode[])[Math.floor(Math.random() * 5)]);
  }, []);

  const handleSwapImages = useCallback(() => {
    setImageA((prev) => {
      setImageB(prev);
      return imageB;
    });
  }, [imageB]);

  // Mouse activity tracking - hide controls after 2 seconds of inactivity
  useEffect(() => {
    const handleMouseMove = () => {
      setShowControls(true);
      
      if (hideControlsTimeoutRef.current) {
        clearTimeout(hideControlsTimeoutRef.current);
      }
      
      hideControlsTimeoutRef.current = setTimeout(() => {
        setShowControls(false);
      }, 2000);
    };

    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseenter", handleMouseMove);
    
    // Initial timeout
    handleMouseMove();
    
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseenter", handleMouseMove);
      if (hideControlsTimeoutRef.current) {
        clearTimeout(hideControlsTimeoutRef.current);
      }
    };
  }, []);

  // keyboard shortcuts: space to pause/play, s for screenshot, r for randomize, w swap
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.key === " ") {
        e.preventDefault();
        setPlaying((p) => !p);
      } else if (e.key.toLowerCase() === "s") {
        handleScreenshot();
      } else if (e.key.toLowerCase() === "r") {
        handleRandomize();
      } else if (e.key.toLowerCase() === "w") {
        handleSwapImages();
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [handleScreenshot, handleRandomize, handleSwapImages]);

  return (
    <div className="fixed inset-0 z-50 flex flex-col bg-background text-foreground dark:bg-black dark:text-white">
      {/* top controls */}
      <div className={`absolute top-4 right-4 z-60 flex gap-3 items-center transition-opacity duration-300 ${
        showControls ? "opacity-100" : "opacity-0 pointer-events-none"
      }`}>
        <div className="rounded-full bg-black/70 text-white border border-white/20 px-3 py-2 text-xs flex items-center gap-2 backdrop-blur-sm shadow-lg">
          <button
            onClick={() => setPlaying((p) => !p)}
            className="px-2 py-1 rounded-md bg-white/10 text-white hover:bg-white/20 transition"
            title="Play / Pause (Space)"
          >
            {playing ? "‚è∏" : "‚èµ"}
          </button>
          <button
            onClick={handleExportGif}
            disabled={!!exporting}
            className="px-2 py-1 rounded-md bg-white/10 text-white hover:bg-white/20 transition disabled:opacity-50 disabled:cursor-not-allowed"
            title={exporting ? "Export in progress" : "Export GIF (512px, 8 frames @ 10fps)"}
          >
            GIF
          </button>
          <button
            onClick={handleRecordWebm}
            disabled={!!exporting}
            className="px-2 py-1 rounded-md bg-white/10 text-white hover:bg-white/20 transition disabled:opacity-50 disabled:cursor-not-allowed"
            title={exporting ? "Export in progress" : "Record WebM (720px, ~0.8s @ 12fps)"}
          >
            üéû
          </button>
          <button
            onClick={handleScreenshot}
            className="px-2 py-1 rounded-md bg-white/10 text-white hover:bg-white/20 transition"
            title="Screenshot (S)"
          >
            üì∑
          </button>
          <button
            onClick={handleRandomize}
            className="px-2 py-1 rounded-md bg-white/10 text-white hover:bg-white/20 transition"
            title="Randomize (R)"
          >
            üé≤
          </button>
          <button
            onClick={handleSwapImages}
            className="px-2 py-1 rounded-md bg-white/10 text-white hover:bg-white/20 transition"
            title="Swap images (W)"
          >
            üîÅ
          </button>
        </div>
      </div>

      {/* left controls */}
      <div className={`absolute left-4 top-4 z-60 w-64 rounded-lg bg-black/70 text-white border border-white/20 p-3 text-xs space-y-2 backdrop-blur-sm shadow-lg transition-opacity duration-300 ${
        showControls ? "opacity-100" : "opacity-0 pointer-events-none"
      }`}>
        <div className="mb-1 text-white font-medium">Vizualiz√°ci√≥</div>

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Glitch <span className="text-white">{targetGlitch.toFixed(2)}</span>
        </label>
        <input
          type="range"
          min={0}
          max={1}
          step={0.01}
          value={targetGlitch}
          onChange={(e) => setTargetGlitch(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Grain <span className="text-white">{targetGrain.toFixed(2)}</span>
        </label>
        <input
          type="range"
          min={0}
          max={0.25}
          step={0.005}
          value={targetGrain}
          onChange={(e) => setTargetGrain(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Slices <span className="text-white">{targetSlices}</span>
        </label>
        <input
          type="range"
          min={2}
          max={24}
          step={1}
          value={targetSlices}
          onChange={(e) => setTargetSlices(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          RGB shift <span className="text-white">{targetRgbShift.toFixed(2)}</span>
        </label>
        <input
          type="range"
          min={0}
          max={0.12}
          step={0.005}
          value={targetRgbShift}
          onChange={(e) => setTargetRgbShift(Number(e.target.value))}
          className="w-full"
        />
      </div>

      {/* right controls */}
      <div className={`absolute right-4 top-16 z-60 w-56 rounded-lg bg-black/70 text-white border border-white/20 p-3 text-xs space-y-2 backdrop-blur-sm shadow-lg transition-opacity duration-300 ${
        showControls ? "opacity-100" : "opacity-0 pointer-events-none"
      }`}>
        <div className="mb-1 text-white font-medium">Tweakek</div>

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Vignette <span className="text-white">{targetVignette.toFixed(2)}</span>
        </label>
        <input
          type="range"
          min={0}
          max={0.3}
          step={0.005}
          value={targetVignette}
          onChange={(e) => setTargetVignette(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Rotation <span className="text-white">{targetRotationDeg}¬∞</span>
        </label>
        <input
          type="range"
          min={-6}
          max={6}
          step={1}
          value={targetRotationDeg}
          onChange={(e) => setTargetRotationDeg(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Scale offset <span className="text-white">{targetScaleOffset.toFixed(3)}</span>
        </label>
        <input
          type="range"
          min={-0.08}
          max={0.08}
          step={0.002}
          value={targetScaleOffset}
          onChange={(e) => setTargetScaleOffset(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Speed <span className="text-white">{speed.toFixed(2)}x</span>
        </label>
        <input
          type="range"
          min={0.5}
          max={1.5}
          step={0.05}
          value={speed}
          onChange={(e) => setSpeed(Number(e.target.value))}
          className="w-full"
        />

        <label className="text-[11px] text-neutral-300 flex justify-between">
          Saturation <span className="text-white">{targetSaturation.toFixed(2)}x</span>
        </label>
        <input
          type="range"
          min={0}
          max={2.5}
          step={0.05}
          value={targetSaturation}
          onChange={(e) => setTargetSaturation(Number(e.target.value))}
          className="w-full"
        />
      </div>

      {/* bottom-left utilities */}
      <div className={`absolute left-4 bottom-4 z-60 w-72 rounded-lg bg-black/70 text-white border border-white/20 p-3 text-xs flex flex-col gap-2 backdrop-blur-sm shadow-lg transition-opacity duration-300 ${
        showControls ? "opacity-100" : "opacity-0 pointer-events-none"
      }`}>
        <div className="flex items-center gap-2">
          <button
            onClick={() => {
              setImageInputValue(imageA);
              setShowImagePicker("A");
            }}
            className="px-2 py-1 rounded bg-white/10 text-white hover:bg-white/20"
          >
            Edit A
          </button>
          <button
            onClick={() => {
              setImageInputValue(imageB);
              setShowImagePicker("B");
            }}
            className="px-2 py-1 rounded bg-white/10 text-white hover:bg-white/20"
          >
            Edit B
          </button>

          <button
            onClick={() => {
              setNoiseOverlay((v) => !v);
            }}
            className="px-2 py-1 rounded bg-white/10 text-white hover:bg-white/20"
          >
            {noiseOverlay ? "Noise ON" : "Noise OFF"}
          </button>

          <button
            onClick={() => setAutoshift((v) => !v)}
            className="px-2 py-1 rounded bg-white/10 text-white hover:bg-white/20"
            title="Auto subtle movement"
          >
            {autoshift ? "Auto" : "Manual"}
          </button>
        </div>

        <div className="flex items-center gap-2">
          <label className="text-[11px] text-neutral-300">Blend</label>
          <select
            value={blendMode}
            onChange={(e) => setBlendMode(e.target.value as BlendMode)}
            className="bg-black/40 border border-white/20 text-white rounded px-2 py-1 text-xs">
            <option value="difference">difference</option>
            <option value="overlay">overlay</option>
            <option value="lighter">lighter</option>
            <option value="screen">screen</option>
            <option value="multiply">multiply</option>
            <option value="source-over">source-over</option>
          </select>

          <label className="text-[11px] text-neutral-300">Hue</label>
          <input
            type="range"
            min={-180}
            max={180}
            step={1}
            value={tintHue}
            onChange={(e) => setTintHue(Number(e.target.value))}
            className="w-full"
          />
        </div>

        <div className="flex items-center gap-2">
          <button
            onClick={() => {
              handleScreenshot();
            }}
            className="flex-1 px-3 py-2 rounded bg-lime-600 text-black font-semibold"
          >
            Screenshot
          </button>
          <button
            onClick={() => {
              setSeed(Math.floor(Math.random() * 99999));
            }}
            className="px-3 py-2 rounded bg-neutral-200 text-neutral-900 hover:bg-neutral-300 dark:bg-white/6 dark:text-white"
            title="Reseed"
          >
            Reseed
          </button>
        </div>

        <div className="text-[10px] text-neutral-600 dark:text-neutral-500">
          Tips: Space=play/pause, S=screenshot, R=randomize, W=swap images. Use gentle values for best screenshots.
        </div>
      </div>

      {/* canvas container */}
      <div className="flex-1 w-full h-full">
        <canvas
          ref={canvasRef}
          className="w-full h-full block"
          style={{ display: "block" }}
        />
      </div>

      {/* footer instruction */}
      <div className={`absolute bottom-4 right-4 z-60 text-xs text-neutral-300 bg-black/70 px-3 py-1 rounded-md border border-white/20 shadow-lg backdrop-blur-sm transition-opacity duration-300 ${
        showControls ? "opacity-100" : "opacity-0 pointer-events-none"
      }`}>
        Use query params ?img1=/path.jpg&amp;img2=/path2.jpg or edit via buttons.
      </div>

      {/* Image Picker Modal */}
      {showImagePicker && (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/50 backdrop-blur-sm">
          <div className="bg-white dark:bg-neutral-900 rounded-lg shadow-xl p-6 w-full max-w-md border border-neutral-200 dark:border-neutral-700">
            <h3 className="text-lg font-semibold mb-4 text-neutral-900 dark:text-white">
              Select Image {showImagePicker}
            </h3>
            
            {/* File Upload */}
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2 text-neutral-700 dark:text-neutral-300">
                Upload Local File
              </label>
              <input
                type="file"
                accept="image/*"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) handleFileUpload(file, showImagePicker);
                }}
                className="w-full text-sm text-neutral-900 dark:text-neutral-300 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-neutral-200 file:text-neutral-900 hover:file:bg-neutral-300 dark:file:bg-neutral-700 dark:file:text-white dark:hover:file:bg-neutral-600"
              />
            </div>

            {/* URL Input */}
            <div className="mb-4">
              <label className="block text-sm font-medium mb-2 text-neutral-700 dark:text-neutral-300">
                Or Enter Image URL
              </label>
              <input
                type="text"
                value={imageInputValue}
                onChange={(e) => setImageInputValue(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    handleUrlInput(imageInputValue, showImagePicker);
                  }
                }}
                placeholder="https://example.com/image.jpg or /img/local.png"
                className="w-full px-3 py-2 border border-neutral-300 dark:border-neutral-600 rounded text-sm bg-white dark:bg-neutral-800 text-neutral-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <p className="text-xs text-neutral-500 dark:text-neutral-400 mt-1">
                Supports: http://, https://, relative paths (/img/...), or data URLs
              </p>
            </div>

            {/* Actions */}
            <div className="flex gap-2 justify-end">
              <button
                onClick={() => {
                  setShowImagePicker(null);
                  setImageInputValue("");
                }}
                className="px-4 py-2 rounded bg-neutral-200 text-neutral-900 hover:bg-neutral-300 dark:bg-neutral-700 dark:text-white dark:hover:bg-neutral-600"
              >
                Cancel
              </button>
              <button
                onClick={() => handleUrlInput(imageInputValue, showImagePicker)}
                className="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600"
              >
                Apply URL
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
